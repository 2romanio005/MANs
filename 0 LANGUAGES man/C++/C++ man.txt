====================================================== КОНЦЕПЦИИ И СЕМАТИКИ ЯЗЫКА С++ =================================================
RAII									- РАИИ. Что каждый ресурс должен выделяться в конструкторе и удаляться в деструкторе.
DRY										- Don't Repeat Yourself.
move сематика							- ну, что можно не копировать обекты, а делать их перемещение через std::move и &&

RVO										- Локальная переменная возвращается из функции избегая конструктор перемещения и копирования
NRVO									- Объект, созданный в точке вызова return, возвращается из функции избегая конструктора перемещения и копирования
https://habr.com/ru/companies/vk/articles/666330/

SOLID									- архитектурные принципы

CRTP									- это метод в C++, при котором класс наследуется от шаблона класса, используя себя в качестве параметра шаблона. Это выглядит примерно так: класс X наследуется от класса-шаблона Y<X>

====================================================== ОПТИМИЗАЦИИ КОМПИЛЯТОРА =============================================

constexpr 								- модификатор фукции, теперь функция может возвращать константное выражение и считается при компиляции (но можно и как обычную использовать), также можно сделать проверку на коректность значения во время компиляции
https://vk.com/@cppstudio-vychisleniya-vo-vremya-kompilyacii

volatile								- модификатор типа, который говорит компилятору не оптимизировать эту переменную
https://habr.com/ru/articles/673428/

noexcept								- модификатор функции, означает, что она не быдет выкидывать исключений, что полезно для оптимизации компилятором. Но это никак не запрещает нам получить исключения, но после них прграмма сразу вылетит без возможности отловить.
https://ru.stackoverflow.com/questions/812038/Как-работает-noexcept-в-c





====================================================== НАСТРОЙКА ПРОВЕРКИ ПРАВИЛЬНОСТИ КОДА ПРИ КОМПИЛЯЦИИ ============================

mutable 								- модификатор типа поля класса, разрешающий редактирование поля в const методах
https://habr.com/ru/companies/infopulse/articles/341264/

explicit								- модифиатор функции запрещающий неявное преобразование типов при её вызове. Для конструктора убирает вызов через {}. Для оператора преобразования типа отключает его неявную форму.
https://habr.com/ru/articles/436296/

assert(I)								- проверка условия I во время рабоыт программы и exit() если оно false. Должно отсутсвтвовать в релизе
static_assert(I, M)						- проверка условия I при компиляции и вывод сообщения M
https://ravesli.com/urok-109-assert-i-static_assert/

#error									- команда препроцессора Си вывода сообщения об ошибке

constexpr 								- модификатор фукции, теперь функция может возвращать константное выражение и считается при компиляции (но можно и как обычную использовать), также можно сделать проверку на коректность значения во время компиляции
https://habr.com/ru/articles/579490/
https://vk.com/@cppstudio-vychisleniya-vo-vremya-kompilyacii

consteval								- требует обязательное вычисление выражений во время компиляции.

constinit								- используется для инициализации статических и глобальных переменных.
https://habr.com/ru/companies/otus/articles/801045/

====================================================== ПРОДВИНУТАЯ РАБОТА С ПАМЯТЬЮ =========================================

lvalue									- (левое значени) объект, который занимает идентифицируемое место в памяти (например, имеет адрес). Ему можно присваивать зачения.
rvalue									- (правое значение) всё, что не lvalue, то у чего нельзя получить адреса, а хранится оно в каком-нбудь регистре или стеке. Это обекты без названий (те что мы hard кодим или которые возвращаются из функций). Значение присваивать в них нельзя
https://habr.com/ru/articles/348198/

std::move(A)							- преобразование А к rvalue типу для последующего вызова конптруктора перемещения
https://habr.com/ru/articles/587644/

const int &a							- ссылка на константное lavlue, может пинимать и rvalue, т.к. переменная не будет изменяться.			использовать для констрторов и операторов копирования
int &&a									- ссылка на ссылку (ссылка на rvalue).   																использовать для конструкторов и операторов перемещения
https://ru.stackoverflow.com/questions/512284/Что-значит-двойной-амперсанд-в-параметрах-функции-и-как-его-использовать

realloc 								- (С) перевыделение памяти, если возможно то в этом же месте


std::unique_ptr							- умный указатель, запрещает множественное владение (за счёт отсутствия оператора и конструктора копирования). Взадение передаётся через конструктор и оператор перемещения
std::shared_ptr							- умный указатель, считающий количество владейльцев. 
std::weak_ptr							- умный указатель, создаваемый из shared_ptr и не добавляющий владелца в счётчик shared_ptr-a, может быть использован для разрыва циклов зависимости
https://habr.com/ru/companies/piter/articles/706866/

__cdecl									- соглашение аргументы функции передаются в стек (помещаются в обратном порядке), а возвращаемое значение передается через EAX регистр (при условии, что это не число с плавающей точкой).
https://habr.com/ru/articles/588925/

====================================================== ПРЕПРОЦЕССОР =============================================================

операторы препроцессора
#										- заключает следующий аргумент макроса в ""
https://learn.microsoft.com/ru-ru/cpp/preprocessor/stringizing-operator-hash?view=msvc-170
@#										- заключает следующий аргумент макроса в ''
https://learn.microsoft.com/ru-ru/cpp/preprocessor/charizing-operator-hash-at?view=msvc-170
##										- помечает, что дальше следует аргумент макроса, а не текст(на случай того, что агрумент надо будет использовать вплотную к другому тексту)
https://learn.microsoft.com/ru-ru/cpp/preprocessor/token-pasting-operator-hash-hash?view=msvc-170


std::apply								- применить функцию ко всем элементам turple



valgrind и Sanitizers программы для отслеживания утечек памяти
https://habr.com/ru/companies/otus/articles/801123/