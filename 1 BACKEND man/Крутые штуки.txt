простое для mod - 2999999777, 2305843009213693951 = 2^61-1, 2999999111, 2999992999, 2999999399

ios_base::sync_with_stdio(false); // в main()
cin.tie(0);                       // в main()
cout.tie(0);                      // в main()

n//k(с округлением вверх) -> (n+k-1)//k

Количество дней в месяцах 
	високосного года: 		31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
	не високостного года:	31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
	
printf("%10.9f", float());    - float с 9 знаками после запятой	
%f - float
%lf - long float
%i - int
%li - long 
%lli - long long
между % и буков - число - размер числа для отступа, для float - форамт вывода
%x - 16-ричная запись
%o - 8-ричная запись
%c - символ
#s - строка

str.substr(начало, длина); // срез строки 

cout.width(n) - разовый размер числа для отступа
while(cin >> n){} - считывание в n до конца данных
iomanip:
	setw(n) = cout.width(n)
	setprecision(n) - кол знаков после запятой
	fixed - с тоякой, а не научный вывод 
 
cstdio:   - переоткрытие потока на чтение и запись из текстового файла
!	проект -> свойства: <название проекта> -> свойства концигурации -> C/C++ -> препроцессор->определение препроцессора -> дописываем ;_CRT_SECURE_NO_WARNINGS
	freopen("input.txt", "r", stdin);   
	freopen("output.txt", "w", stdout);
	
fstream:
	ofstream fout;
	ifstream fin;

unordered_map<>   - ассоциативный контейнер, содержащий пары ключ-значение с уникальными ключами. Поиск, вставка и удаление элементов имеют среднюю сложность с постоянным временем.
set:
	set<, greater <>> - все элементы отсортированны без повторов greater <> - в обратную сторону
	multiset<>        - set с повторами
map:
	map<type key, type val> - храним много разных элементов
	a.find(val) - итератор на нужный элемент(если такого нет то на a.end())
	


algorithm:
	lower_bound(a, a + size, find) - a;    // первый нужный элемент
	upper_bound(a, a + size, find) - a;    // следующий отличающийся за нужным элементом
	binary_search(a, a + sizee, find);     // есть.нер элемент в массиве

tuple:
	tuple<int, int, int...> храним сколько угодно значение
	get<const int>(tuple элемент) - получить значение из tuple

контейнер<тип>::reverse_iterator - итератор в обратную сторону(например для binary_search в массиве отсортированным в обратную сторону)
инициализация - rbegin() - конец масива, rend() - перед началом массива

BFS - записываем всё в очередь и их глубину
DFS - отмечаем где были и не идём туда

топологическая сортировка - сортирум по времени выхода из dfs
снм - объединение в группы/разделение на группы (обратный порядок). переподвешиваем деревья к корню при нахождении корня, подвешиваем меньшее дерево к большему

выделить вершины связности - в dfs дереве у каждой вершны записать минимальную вершину возврата, найти мосты и запустить dfs без мостов оъединяя все вернины в группы
выделить вершины сильной связности - топ сорт; dfs по развёрнутому графу, объединяя вершины одного цикла в одну вершину и если из ней есть выход в вершину другой группы, то добавляем ребро.

дерево отрезкв храним так: корень - 0, у вершины i сыновья - i * 2 + 1  и   i * 2 + 2
спуск - если мы за пределами искомого диапазона return 0, если мы полностю внутри него return my, иначе рекурсия к детям
неявное изменение - опускаемся и записываем в крайние вершины изменение(которое будем пропихивать при обращение к потомкам)

разделение на подотрезки длинной sqrt(n) - перерастред. когда длина любого отрезка (больше в два раза чем в начале, или равна 0)(перера. через одномерный массив)
декартово дерево - X - бинарное дерево, Y - у всего поддерева Y меньше чем мой(раздаём случайно) реализуем разделение и соединение, через них все ост.


Скобочные последовательности:
	Количество ПСП из n пар скобок  = C(n):
		C(n) = (C(n - 1) * 2*n * (2*n - 1)) / (n * (n + 1))
		пс: n массив нужно на n + 1 и нельзя начинать цикл с 0
	Все ПСП из n скобок в лексиграфическом порядке:
		можно рекурсивно добавлять по одной скобке:
		если открытых < n / 2 то можно добавить открытую
		если сумма скобок > 0 то можно добавить закрытую
	Кол ПСП с циклическими сдвигами:
		Давайте идти по строке и считать баланс префикса. Циклический сдвиг нужно делать в тех местах, в
		которых баланс будет минимально возможным. Таким образом, задача сводится к нахождению числа
		минимумом балансов.
	
	следующая ПСП:
		находим наибольший префикс который можно не изменять(идём с конца пока не найдём то, что можно поменять на больший)
		увеличиваем найденый(след эл после префикса) и делаем наименьший постфикс
	
	таблица длина СП на баланс СП (развернуть):
		получить номер ПСП:
			идём по таблице и суммируем те последовательности которые перед нами(когда мы закрываем, то пропускаем все открывающие)
		получить ПСП по номеру:
			открываем тогда когда при открывании будет > чем сейчас
			идём по таблице и вычитаем из номера те последовательности которые перед нами(когда мы закрываем, то пропускаем все открывающие)
Геометрия:
	if ((x1 - x3) * (y2 - y3) - (x2 - x3) * (y1 - y3) == 0) { cout << "Точки лежат на одной прямой" << endl; }


Графы:
	BFS - поиск в ширину - поиск кратчайшего пути //для другого ИСПОЛЬЗУЙ DFS
	Кладём в очредь посешённые вершины: изачально в очереди начальная вершниа, после там все вершины исходящие из начальной при этом пишем в вершины их глубину, обходим по увеличению глубины

	DFS - обход в глубину
	Рекурсия по всем вершинам из начальной, записываем в вершины посетили ли мы их, идём только в непосещенные. Внешним циклом запускаем из всех вершин, что не посещены
	
	Топологическая сортировка
	когда закончили обработку вершины через DFS записываем её в конец массива, таким образом у нас вначале массива листья а корень рёбра идут из меньших индексов в большие
	
	Дейкстры - поиск короткого пути на взвешеном графе
	Обрабатываем вершну путь до которой самый короткий из известных, обновлям все вершины исходяшие из неё, добавляя в set те, до которых путь нашли короче. Одну вершину не обрабатываем дважды, через массив used!
	
	Флойда - кратчайший путь на взвешеном графе с отрицательными рёбрами, без отриц циклов, от всех вершин до всех
	f[i][j] = путь от i до j
	for( int k = 0; k < n; ++k)
		for(int i = 0; i < n; ++i)
			for(int j = 0; j < n; ++j)
				if(f[i][k] < INF && f[k][j] < INF && f[i][k] + f[k][j] < f[i][j])
					f[i][j] = f[i][k] + f[k][j];
	
	
	Форда-Беллмана - кратчайший путь на взвешеном графе с отрицательными рёбрама, без отриц циклов от одной вершины до другой
1)	vector<pair<pair<int, int>, int>> g; // ребро из first.first в first.second длинной second
	f[start] = 0; f[i] = INF;
	for( int k = 0; k < n - 1; ++k)
		for( int i = 0; i < g.size(); ++i)
			if(f[g[i].first.first] + g[i].second < f[g[i].first.second] && f[g[i].first.first] != INF){
				f[g[i].first.second] = f[g[i].first.first] + f[g[i].second];
			}
	
2)	vector<vector<pair<int, int>>> g; // список смежности 
	f[start][0] = 0; f[i][0] = INF;
	for( int k = 0; k < n - 1; ++k)
		for(int u = 0; u < n; ++u)
			f[u][k + 1] = min(f[u][k + 1], f[u][k]); // убрать если нужен путь именно нужной длинны
			for(int v = 0; v < g[u].size(); ++v)
				f[g[u][v].first][k + 1] = min(f[g[u][v].first][k + 1], f[g[u][v].first][k] + g[u][v].second);
	
	
	
	
	
	
	
	
	
	
	